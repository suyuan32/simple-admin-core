// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/suyuan32/simple-admin-core/rpc/ent/api"
	"github.com/suyuan32/simple-admin-core/rpc/ent/configuration"
	"github.com/suyuan32/simple-admin-core/rpc/ent/department"
	"github.com/suyuan32/simple-admin-core/rpc/ent/dictionary"
	"github.com/suyuan32/simple-admin-core/rpc/ent/dictionarydetail"
	"github.com/suyuan32/simple-admin-core/rpc/ent/inventory"
	"github.com/suyuan32/simple-admin-core/rpc/ent/menu"
	"github.com/suyuan32/simple-admin-core/rpc/ent/oauthprovider"
	"github.com/suyuan32/simple-admin-core/rpc/ent/position"
	"github.com/suyuan32/simple-admin-core/rpc/ent/product"
	"github.com/suyuan32/simple-admin-core/rpc/ent/role"
	"github.com/suyuan32/simple-admin-core/rpc/ent/stockmovement"
	"github.com/suyuan32/simple-admin-core/rpc/ent/token"
	"github.com/suyuan32/simple-admin-core/rpc/ent/user"
	"github.com/suyuan32/simple-admin-core/rpc/ent/warehouse"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type APIPager struct {
	Order  api.OrderOption
	Filter func(*APIQuery) (*APIQuery, error)
}

// APIPaginateOption enables pagination customization.
type APIPaginateOption func(*APIPager)

// DefaultAPIOrder is the default ordering of API.
var DefaultAPIOrder = Desc(api.FieldID)

func newAPIPager(opts []APIPaginateOption) (*APIPager, error) {
	pager := &APIPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultAPIOrder
	}
	return pager, nil
}

func (p *APIPager) ApplyFilter(query *APIQuery) (*APIQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// APIPageList is API PageList result.
type APIPageList struct {
	List        []*API       `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *APIQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...APIPaginateOption,
) (*APIPageList, error) {

	pager, err := newAPIPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &APIPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultAPIOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type ConfigurationPager struct {
	Order  configuration.OrderOption
	Filter func(*ConfigurationQuery) (*ConfigurationQuery, error)
}

// ConfigurationPaginateOption enables pagination customization.
type ConfigurationPaginateOption func(*ConfigurationPager)

// DefaultConfigurationOrder is the default ordering of Configuration.
var DefaultConfigurationOrder = Desc(configuration.FieldID)

func newConfigurationPager(opts []ConfigurationPaginateOption) (*ConfigurationPager, error) {
	pager := &ConfigurationPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultConfigurationOrder
	}
	return pager, nil
}

func (p *ConfigurationPager) ApplyFilter(query *ConfigurationQuery) (*ConfigurationQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ConfigurationPageList is Configuration PageList result.
type ConfigurationPageList struct {
	List        []*Configuration `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (_m *ConfigurationQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...ConfigurationPaginateOption,
) (*ConfigurationPageList, error) {

	pager, err := newConfigurationPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &ConfigurationPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultConfigurationOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type DepartmentPager struct {
	Order  department.OrderOption
	Filter func(*DepartmentQuery) (*DepartmentQuery, error)
}

// DepartmentPaginateOption enables pagination customization.
type DepartmentPaginateOption func(*DepartmentPager)

// DefaultDepartmentOrder is the default ordering of Department.
var DefaultDepartmentOrder = Desc(department.FieldID)

func newDepartmentPager(opts []DepartmentPaginateOption) (*DepartmentPager, error) {
	pager := &DepartmentPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDepartmentOrder
	}
	return pager, nil
}

func (p *DepartmentPager) ApplyFilter(query *DepartmentQuery) (*DepartmentQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DepartmentPageList is Department PageList result.
type DepartmentPageList struct {
	List        []*Department `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (_m *DepartmentQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...DepartmentPaginateOption,
) (*DepartmentPageList, error) {

	pager, err := newDepartmentPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DepartmentPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDepartmentOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type DictionaryPager struct {
	Order  dictionary.OrderOption
	Filter func(*DictionaryQuery) (*DictionaryQuery, error)
}

// DictionaryPaginateOption enables pagination customization.
type DictionaryPaginateOption func(*DictionaryPager)

// DefaultDictionaryOrder is the default ordering of Dictionary.
var DefaultDictionaryOrder = Desc(dictionary.FieldID)

func newDictionaryPager(opts []DictionaryPaginateOption) (*DictionaryPager, error) {
	pager := &DictionaryPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDictionaryOrder
	}
	return pager, nil
}

func (p *DictionaryPager) ApplyFilter(query *DictionaryQuery) (*DictionaryQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DictionaryPageList is Dictionary PageList result.
type DictionaryPageList struct {
	List        []*Dictionary `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (_m *DictionaryQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...DictionaryPaginateOption,
) (*DictionaryPageList, error) {

	pager, err := newDictionaryPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DictionaryPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDictionaryOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type DictionaryDetailPager struct {
	Order  dictionarydetail.OrderOption
	Filter func(*DictionaryDetailQuery) (*DictionaryDetailQuery, error)
}

// DictionaryDetailPaginateOption enables pagination customization.
type DictionaryDetailPaginateOption func(*DictionaryDetailPager)

// DefaultDictionaryDetailOrder is the default ordering of DictionaryDetail.
var DefaultDictionaryDetailOrder = Desc(dictionarydetail.FieldID)

func newDictionaryDetailPager(opts []DictionaryDetailPaginateOption) (*DictionaryDetailPager, error) {
	pager := &DictionaryDetailPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDictionaryDetailOrder
	}
	return pager, nil
}

func (p *DictionaryDetailPager) ApplyFilter(query *DictionaryDetailQuery) (*DictionaryDetailQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DictionaryDetailPageList is DictionaryDetail PageList result.
type DictionaryDetailPageList struct {
	List        []*DictionaryDetail `json:"list"`
	PageDetails *PageDetails        `json:"pageDetails"`
}

func (_m *DictionaryDetailQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...DictionaryDetailPaginateOption,
) (*DictionaryDetailPageList, error) {

	pager, err := newDictionaryDetailPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DictionaryDetailPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDictionaryDetailOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type InventoryPager struct {
	Order  inventory.OrderOption
	Filter func(*InventoryQuery) (*InventoryQuery, error)
}

// InventoryPaginateOption enables pagination customization.
type InventoryPaginateOption func(*InventoryPager)

// DefaultInventoryOrder is the default ordering of Inventory.
var DefaultInventoryOrder = Desc(inventory.FieldID)

func newInventoryPager(opts []InventoryPaginateOption) (*InventoryPager, error) {
	pager := &InventoryPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultInventoryOrder
	}
	return pager, nil
}

func (p *InventoryPager) ApplyFilter(query *InventoryQuery) (*InventoryQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// InventoryPageList is Inventory PageList result.
type InventoryPageList struct {
	List        []*Inventory `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *InventoryQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...InventoryPaginateOption,
) (*InventoryPageList, error) {

	pager, err := newInventoryPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &InventoryPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultInventoryOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type MenuPager struct {
	Order  menu.OrderOption
	Filter func(*MenuQuery) (*MenuQuery, error)
}

// MenuPaginateOption enables pagination customization.
type MenuPaginateOption func(*MenuPager)

// DefaultMenuOrder is the default ordering of Menu.
var DefaultMenuOrder = Desc(menu.FieldID)

func newMenuPager(opts []MenuPaginateOption) (*MenuPager, error) {
	pager := &MenuPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultMenuOrder
	}
	return pager, nil
}

func (p *MenuPager) ApplyFilter(query *MenuQuery) (*MenuQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// MenuPageList is Menu PageList result.
type MenuPageList struct {
	List        []*Menu      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *MenuQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...MenuPaginateOption,
) (*MenuPageList, error) {

	pager, err := newMenuPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &MenuPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultMenuOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type OauthProviderPager struct {
	Order  oauthprovider.OrderOption
	Filter func(*OauthProviderQuery) (*OauthProviderQuery, error)
}

// OauthProviderPaginateOption enables pagination customization.
type OauthProviderPaginateOption func(*OauthProviderPager)

// DefaultOauthProviderOrder is the default ordering of OauthProvider.
var DefaultOauthProviderOrder = Desc(oauthprovider.FieldID)

func newOauthProviderPager(opts []OauthProviderPaginateOption) (*OauthProviderPager, error) {
	pager := &OauthProviderPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultOauthProviderOrder
	}
	return pager, nil
}

func (p *OauthProviderPager) ApplyFilter(query *OauthProviderQuery) (*OauthProviderQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// OauthProviderPageList is OauthProvider PageList result.
type OauthProviderPageList struct {
	List        []*OauthProvider `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (_m *OauthProviderQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...OauthProviderPaginateOption,
) (*OauthProviderPageList, error) {

	pager, err := newOauthProviderPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &OauthProviderPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultOauthProviderOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type PositionPager struct {
	Order  position.OrderOption
	Filter func(*PositionQuery) (*PositionQuery, error)
}

// PositionPaginateOption enables pagination customization.
type PositionPaginateOption func(*PositionPager)

// DefaultPositionOrder is the default ordering of Position.
var DefaultPositionOrder = Desc(position.FieldID)

func newPositionPager(opts []PositionPaginateOption) (*PositionPager, error) {
	pager := &PositionPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultPositionOrder
	}
	return pager, nil
}

func (p *PositionPager) ApplyFilter(query *PositionQuery) (*PositionQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// PositionPageList is Position PageList result.
type PositionPageList struct {
	List        []*Position  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *PositionQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...PositionPaginateOption,
) (*PositionPageList, error) {

	pager, err := newPositionPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &PositionPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultPositionOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type ProductPager struct {
	Order  product.OrderOption
	Filter func(*ProductQuery) (*ProductQuery, error)
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*ProductPager)

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = Desc(product.FieldID)

func newProductPager(opts []ProductPaginateOption) (*ProductPager, error) {
	pager := &ProductPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultProductOrder
	}
	return pager, nil
}

func (p *ProductPager) ApplyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ProductPageList is Product PageList result.
type ProductPageList struct {
	List        []*Product   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *ProductQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...ProductPaginateOption,
) (*ProductPageList, error) {

	pager, err := newProductPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &ProductPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultProductOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type RolePager struct {
	Order  role.OrderOption
	Filter func(*RoleQuery) (*RoleQuery, error)
}

// RolePaginateOption enables pagination customization.
type RolePaginateOption func(*RolePager)

// DefaultRoleOrder is the default ordering of Role.
var DefaultRoleOrder = Desc(role.FieldID)

func newRolePager(opts []RolePaginateOption) (*RolePager, error) {
	pager := &RolePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultRoleOrder
	}
	return pager, nil
}

func (p *RolePager) ApplyFilter(query *RoleQuery) (*RoleQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// RolePageList is Role PageList result.
type RolePageList struct {
	List        []*Role      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *RoleQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...RolePaginateOption,
) (*RolePageList, error) {

	pager, err := newRolePager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &RolePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultRoleOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type StockMovementPager struct {
	Order  stockmovement.OrderOption
	Filter func(*StockMovementQuery) (*StockMovementQuery, error)
}

// StockMovementPaginateOption enables pagination customization.
type StockMovementPaginateOption func(*StockMovementPager)

// DefaultStockMovementOrder is the default ordering of StockMovement.
var DefaultStockMovementOrder = Desc(stockmovement.FieldID)

func newStockMovementPager(opts []StockMovementPaginateOption) (*StockMovementPager, error) {
	pager := &StockMovementPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultStockMovementOrder
	}
	return pager, nil
}

func (p *StockMovementPager) ApplyFilter(query *StockMovementQuery) (*StockMovementQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// StockMovementPageList is StockMovement PageList result.
type StockMovementPageList struct {
	List        []*StockMovement `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (_m *StockMovementQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...StockMovementPaginateOption,
) (*StockMovementPageList, error) {

	pager, err := newStockMovementPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &StockMovementPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultStockMovementOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type TokenPager struct {
	Order  token.OrderOption
	Filter func(*TokenQuery) (*TokenQuery, error)
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*TokenPager)

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = Desc(token.FieldID)

func newTokenPager(opts []TokenPaginateOption) (*TokenPager, error) {
	pager := &TokenPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *TokenPager) ApplyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// TokenPageList is Token PageList result.
type TokenPageList struct {
	List        []*Token     `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *TokenQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...TokenPaginateOption,
) (*TokenPageList, error) {

	pager, err := newTokenPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &TokenPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultTokenOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type UserPager struct {
	Order  user.OrderOption
	Filter func(*UserQuery) (*UserQuery, error)
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*UserPager)

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = Desc(user.FieldID)

func newUserPager(opts []UserPaginateOption) (*UserPager, error) {
	pager := &UserPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultUserOrder
	}
	return pager, nil
}

func (p *UserPager) ApplyFilter(query *UserQuery) (*UserQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// UserPageList is User PageList result.
type UserPageList struct {
	List        []*User      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *UserQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...UserPaginateOption,
) (*UserPageList, error) {

	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &UserPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultUserOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WarehousePager struct {
	Order  warehouse.OrderOption
	Filter func(*WarehouseQuery) (*WarehouseQuery, error)
}

// WarehousePaginateOption enables pagination customization.
type WarehousePaginateOption func(*WarehousePager)

// DefaultWarehouseOrder is the default ordering of Warehouse.
var DefaultWarehouseOrder = Desc(warehouse.FieldID)

func newWarehousePager(opts []WarehousePaginateOption) (*WarehousePager, error) {
	pager := &WarehousePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWarehouseOrder
	}
	return pager, nil
}

func (p *WarehousePager) ApplyFilter(query *WarehouseQuery) (*WarehouseQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WarehousePageList is Warehouse PageList result.
type WarehousePageList struct {
	List        []*Warehouse `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (_m *WarehouseQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WarehousePaginateOption,
) (*WarehousePageList, error) {

	pager, err := newWarehousePager(opts)
	if err != nil {
		return nil, err
	}

	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &WarehousePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := _m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultWarehouseOrder)
	}

	_m = _m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
